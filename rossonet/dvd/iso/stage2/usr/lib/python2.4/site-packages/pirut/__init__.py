# Copyright 2005-2007  Red Hat, Inc.
#
# Jeremy Katz <katzj@redhat.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 only
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

import os, sys, fcntl
import logging
import string
import time
import urllib2
# # Python gettext:
# import gettext

import gobject
import gtk
import gtk.glade
import pango

import yum
import yum.plugins
import yum.Errors
from yum.constants import *
import urlgrabber, urlgrabber.progress

import DetailsDialog
import GroupSelector
import PackageList
import Progress
import RepoSelector
from constants import *
from Errors import *

from rhpl.translate import _, N_, utf8, textdomain


# # Python gettext:
# t = gettext.translation(I18N_DOMAIN, "/usr/share/locale", fallback = True)
# _ = t.lgettext

PirutDetailsDialog = DetailsDialog.PirutDetailsDialog
PirutProgress = Progress.PirutProgress
PirutCancellableProgress = Progress.PirutCancellableProgress
PirutDepsolveProgress = Progress.PirutDepsolveProgress
PirutProgressCallback = Progress.PirutProgressCallback
PirutPackageList = PackageList.PirutPackageList
PirutGroupSelector = GroupSelector.GroupSelector
PirutRepoSelector = RepoSelector.RepoSelector

# lame main loop runner... this should probably just be where we need it
def _runGtkMain(*args):
    while gtk.events_pending():
        gtk.main_iteration()

import rpm
rpm.addMacro("_i18ndomains", "redhat-dist")

remove_blacklist = ('yum', 'pirut', 'glibc', 'rpm-libs', 'rpm', 'kernel', 'kernel-xen', 'kernel-PAE')
rebootpkgs = ("kernel", "kernel-smp", "kernel-xen-hypervisor", "kernel-PAE",
              "kernel-xen0", "kernel-xenU", "kernel-xen", "kernel-xen-guest",
              "glibc", "hal", "dbus", "xen")

class GraphicalYumBase(yum.YumBase):
    # FIXME: this is pulled directly from yum/output.py just for debugging
    def listTransaction(self):
        """returns a string rep of the  transaction in an easy-to-read way."""
        
        self.tsInfo.makelists()
        if len(self.tsInfo) > 0:
            out = """
=============================================================================
 %-22s  %-9s  %-15s  %-16s  %-5s
=============================================================================
""" % ('Package', 'Arch', 'Version', 'Repository', 'Size')
        else:
            out = ""

        for (action, pkglist) in [('Installing', self.tsInfo.installed),
                            ('Updating', self.tsInfo.updated),
                            ('Removing', self.tsInfo.removed),
                            ('Installing for dependencies', self.tsInfo.depinstalled),
                            ('Updating for dependencies', self.tsInfo.depupdated),
                            ('Removing for dependencies', self.tsInfo.depremoved)]:
            if pkglist:
                totalmsg = "%s:\n" % action
            for txmbr in pkglist:
                (n,a,e,v,r) = txmbr.pkgtup
                evr = txmbr.po.printVer()
                repoid = txmbr.repoid
                pkgsize = float(txmbr.po.size())
                size = pkgsize
                msg = " %-22s  %-9s  %-15s  %-16s  %5s\n" % (n, a,
                              evr, repoid, size)
                for (obspo, relationship) in txmbr.relatedto:
                    if relationship == 'obsoletes':
                        appended = '     replacing  %s.%s %s\n\n' % (obspo.name, obspo.arch, obspo.printVer())
                        msg = msg+appended
                totalmsg = totalmsg + msg
        
            if pkglist:
                out = out + totalmsg

        summary = """
Transaction Summary
=============================================================================
Install  %5.5s Package(s)         
Update   %5.5s Package(s)         
Remove   %5.5s Package(s)         
""" % (len(self.tsInfo.installed + self.tsInfo.depinstalled),
       len(self.tsInfo.updated + self.tsInfo.depupdated),
       len(self.tsInfo.removed + self.tsInfo.depremoved))
        out = out + summary
        
        return out

    
    def __init__(self, run_long = True, configfn = "/etc/yum.conf",
                 rootdir="/", plugins=True):
        """run_long is whether or not to run 'long' steps."""

        yum.YumBase.__init__(self)
        self.__allowRepoEdit = False

        try:
            self.doConfigSetup(fn=configfn, root=rootdir, init_plugins=plugins,
                               plugin_types=(yum.plugins.TYPE_CORE,))
        except yum.Errors.ConfigError, e:
            raise PirutError, e

        self.unsignedok = False

        if run_long:
            self.reposSetup()

        self.mediagrabber = self.pirutCDHandler

    def pirutCDHandler(self, *args, **kwargs):
        import HalCD
        import dbus
        print "args:",  args
        print "kwargs:", kwargs

        mediaid = kwargs["mediaid"]
        discnum = kwargs["discnum"]
        name = kwargs["name"]

        found = False
        hal = HalCD.HALManager()
        
        while 1:
            cddevs = hal.FindDeviceByCapability('storage.cdrom')
            umount = False
            for cdudi in cddevs:
                dev = hal.GetBlockDeviceByUDI(cdudi)
                if not dev:
                    print "error getting block device"
                    continue
                try:
                    dev.lock("pirut")
                except dbus.DBusException, e:
                    print "error locking %s: %s" %(cdudi, e)
                    continue

                if not dev.volumedev:
                    dev.unlock()
                    continue

                if not dev["volume.is_mounted"]:
                    try:
                        dev.mount()
                        umount = True                        
                    except dbus.DBusException, e:
                        print "error mounting %s: %s" %(cdudi, e)
                        dev.unlock()
                        continue
                
                if not dev["volume.is_mounted"]:
                    dev.unlock()
                    continue
                
                mnt = dev["volume.mount_point"]
                if os.path.exists("%s/.discinfo" %(mnt,)):
                    f = open("%s/.discinfo" %(mnt,), "r")
                    lines = f.readlines()
                    f.close()

                    theid = lines[0].strip()
                    discs = map(lambda x: int(x), lines[3].strip().split(","))
                    print "discs is: ", discs, ", discnum is:", discnum
                    
                    if mediaid != theid or discnum not in discs: 
                        print "didn't find it on ", cdudi
                        if umount:
                            dev.umount()
                        dev.unlock()
                        continue

#                    print "copying %s to %s" %(kwargs["relative"], kwargs["local"])
                    from urlgrabber.grabber import URLGrabber, URLGrabError
                    ug = URLGrabber(checkfunc = kwargs["checkfunc"])
                    try:
                        ug.urlgrab("%s/%s" %(mnt, kwargs["relative"]),
                                   kwargs["local"], text=kwargs["text"],
                                   range=kwargs["range"], copy_local=1)
                    except (IOError, URLGrabError):
                        pass
                    else:
                        found = True
                if umount:
                    dev.umount()
                dev.unlock()
                
                if found:
                    break

            if found:
                break

            if discnum:
                insertstr = _("Please insert %s (disc %d) into your CD drive") %(name, discnum)
            else:
                insertstr = _("Please insert %s into your CD drive") %(name,)

            # FIXME: doing this only on the repo path is kind of hacky...
            # what if they want to edit during download?
            if self.__allowRepoEdit:
                b = [('gtk-cancel', gtk.RESPONSE_CANCEL),
                     (_("Repository Manager"), 5, 'gtk-edit'),
                     ('gtk-ok', gtk.RESPONSE_OK)]
            else:
                b = [('gtk-cancel', gtk.RESPONSE_CANCEL),
                     ('gtk-ok', gtk.RESPONSE_OK)]

            d = PirutDetailsDialog(None, gtk.MESSAGE_INFO, b,
                                   _("Insert CD"), insertstr)
            rc = d.run()
            d.destroy()
            if rc == gtk.RESPONSE_CANCEL:
                break
            elif rc == 5:
                d = PirutRepoSelector(self)
                rc = d.run()
                d.destroy()
                # if things have changed, then we need to redo repo setup
                if rc:
                    self.reset(False, True)
                    raise PirutResetError, "resetting..."
                else:
                    break
                

        if not found:
            raise yum.Errors.MediaError, "don't have the CD"
        return kwargs["local"]
        
#        import pdb; pdb.set_trace()
#        raise Errors.MediaError, "asdf"

    def reset(self, resetRepos = False, doClose = False):
        self.closeRpmDB()
        del self.tsInfo

        if resetRepos or doClose:
            # having to do all of this is kind of disgusting; we should just
            # be able to del self.repos + self.pkgSack and then refresh
            # but that doesn't work with yum 3.2.4
            self.close()
            self.repos._setup = False
            self.repos.pkgSack.sacks = {}
            del self.pkgSack

        if resetRepos:
            self.doRefreshRepos()
        
            try:
                self.doGroupSetup()
            except yum.Errors.GroupsError:
                log = logging.getLogger("yum")
                log.warn("no groups present!")
            except (yum.Errors.RepoError, OSError), e:
                raise PirutDownloadError, e

    def reposSetup(self, callback = None, thisrepo = None):
        if callback:
            self.repos.setProgressBar(callback)
            if thisrepo is None:
                callback.num_tasks += 3 * len(self.repos.listEnabled())
            else:
                callback.num_tasks += 3

            # for what we do here
            callback.num_tasks += 6

        self.doLock(YUM_PID_FILE)

        try:
            self.doTsSetup()
            self.doRpmDBSetup()
        except (yum.Errors.RepoError, OSError), e:
            raise PirutDownloadError, e

        if callback: callback.next_task()
        try:
            self.doRepoSetup(thisrepo)
        except (yum.Errors.RepoError, OSError), e:
            raise PirutDownloadError, e
        if callback: callback.next_task()  
        try:
            self.doGroupSetup()
        except yum.Errors.GroupsError:
            log = logging.getLogger("yum")
            log.warn("no groups present!")
        except (yum.Errors.RepoError, OSError), e:
            raise PirutDownloadError, e
        if callback: callback.next_task() # hack
        try:
            self.doSackSetup()
        except (yum.Errors.RepoError, OSError), e:
            raise PirutDownloadError, e
        if callback: callback.next_task()        

        if callback: self.repos.callback = None
    
    def doRefreshRepos(self, thisrepo = None, destroy = True, progress = False):
        pbar = PirutProgressCallback(_("Retrieving software information"),
                                     self.mainwin)
        if progress:
            pbar.show()
        self._busyCursor()
        while True:
            try:
                self.__allowRepoEdit = True
                self.reposSetup(pbar, thisrepo)
                self.__allowRepoEdit = False
            except yum.Errors.LockError:
                d = gtk.MessageDialog(self.mainwin, gtk.DIALOG_MODAL,
                                      gtk.MESSAGE_ERROR, gtk.BUTTONS_NONE,
                                      _("Another application is currently "
                                        "running which is accessing software "
                                        "information."))
                b = d.add_button(_("_Quit"), 0)
                b.set_image(gtk.image_new_from_stock("gtk-quit", gtk.ICON_SIZE_BUTTON))
                b = d.add_button(_("_Retry"), 1)
                b.set_image(gtk.image_new_from_stock("gtk-redo", gtk.ICON_SIZE_BUTTON))
                d.set_default_response(1)
                d.show_all()
                rc = d.run()
                d.destroy()
                if rc == 1:
                    continue
                else:
                    self.quit(unlock = False)
            except PirutResetError:
                # repos have been reset...
                pbar.set_fraction(0.0)
                pbar.show()
                continue
            except PirutCancelledError, e:
                pbar.hide()
                self._normalCursor()
                d = PirutDetailsDialog(self.mainwin, gtk.MESSAGE_ERROR, None,
                                       _("Cancel?"))
                d.format_secondary_text(_("Software information is required "
                                          "to continue."))
                d.add_button(_("_Exit"), gtk.RESPONSE_CANCEL, 'gtk-quit')
                d.add_button(_("_Continue retrieval"), gtk.RESPONSE_OK,
                             'gtk-redo')
                rc = d.run()
                d.destroy()
                if rc == gtk.RESPONSE_CANCEL:
                    self.quit()
                else:
                    pbar.set_fraction(0.0)
                    pbar.show()
                    continue
            except (IOError, PirutDownloadError, yum.Errors.RepoError), e:
                pbar.hide()
                self._normalCursor()

                d = PirutDetailsDialog(self.mainwin, gtk.MESSAGE_ERROR,
                                       [('gtk-quit', gtk.RESPONSE_CANCEL),
                                        (_("Repository Manager"), 5,
                                         'gtk-edit')],
                                       _("Unable to retrieve software information"))
                d.format_secondary_text(_("Unable to retrieve software "
                                          "information. This could be caused by "
                                          "not having a network connection "
                                          "available."))
                d.set_details("%s" %(e,))
                rc = d.run()
                d.destroy()
                if rc == 5:
                    d = PirutRepoSelector(self)
                    rc = d.run()
                    d.destroy()
                    # if things have changed, then we need to redo repo setup
                    if rc:
                        self.reset(False, True)
                        pbar.set_fraction(0.0)
                        pbar.show()
                        continue
                self.quit()
            else:
                break

        if destroy:
            self._normalCursor()
            pbar.destroy()
        else:
            return pbar

    def simpleDBInstalled(self, name, arch=None):
        # FIXME: doing this directly instead of using self.rpmdb.installed()
        # speeds things up by 400%
        mi = self.ts.ts.dbMatch('name', name)
        if mi.count() == 0:
            return False
        if arch is None:
            return True
        if arch in map(lambda h: h['arch'], mi):
            return True
        return False

    def isPackageInstalled(self, name = None, epoch = None, version = None,
                           release = None, arch = None, po = None):
        # FIXME: this sucks.  we should probably suck it into yum proper
        # but it'll need a bit of cleanup first.
        if po is not None:
            (name, epoch, version, release, arch) = po.returnNevraTuple()
            
        installed = False
        if name and not (epoch or version or release or arch):
            installed = self.simpleDBInstalled(name)
        elif self.rpmdb.installed(name = name, epoch = epoch, ver = version,
                                rel = release, arch = arch):
            installed = True
            
        lst = self.tsInfo.matchNaevr(name = name, epoch = epoch,
                                     ver = version, rel = release,
                                     arch = arch)
        for txmbr in lst:
            if txmbr.output_state in TS_INSTALL_STATES:
                return True
        if installed and len(lst) > 0:
            # if we get here, then it was installed, but it's in the tsInfo
            # for an erase or obsoleted --> not going to be installed at end
            return False
        return installed

    def isGroupInstalled(self, grp):
        if grp.selected:
            return True
        elif grp.installed and not grp.toremove:
            return True
        if (len(grp.optional_packages.keys()) ==
            len(grp.mandatory_packages.keys()) ==
            len(grp.default_packages.keys()) == 0) and \
            len(grp.conditional_packages.keys()) != 0:
            return True
        return False

    def deselectGroup(self, grpid):
        group = self.comps.return_group(grpid)
        if group.selected:
            yum.YumBase.deselectGroup(self, grpid)
        else:
            self.groupRemove(grpid)

    def selectGroup(self, grpid):
        group = self.comps.return_group(grpid)
        if group.toremove:
            self.groupUnremove(grpid)
        else:
            yum.YumBase.selectGroup(self, grpid)

    def downloadPackages(self, mainwin):
        def downloadErrorDialog(mainwin, secondary = None, details = None):
            self.repos.setProgressBar(None)
            pbar.destroy()
            
            d = PirutDetailsDialog(mainwin, gtk.MESSAGE_ERROR,
                                   [('gtk-ok', gtk.RESPONSE_OK)],
                                   _("Error downloading packages"),
                                   secondary)
            if details:
                d.set_details("%s" %(details,))
            d.run()
            d.destroy()
            
            raise PirutDownloadError


        dlpkgs = map(lambda x: x.po, filter(lambda txmbr:
                                            txmbr.ts_state in ("i", "u"),
                                            self.tsInfo.getMembers()))
        
        pbar = PirutProgressCallback(_("Downloading packages"), mainwin,
                                     len(dlpkgs))
        self.repos.setProgressBar(pbar)
        pbar.show()
        try:
            probs = self.downloadPkgs(dlpkgs)
        except (yum.Errors.RepoError, OSError), errmsg:
            downloadErrorDialog(mainwin, details = errmsg)
        except PirutCancelledError:
            downloadErrorDialog(mainwin, _("Download was cancelled."))
        except IndexError:
            downloadErrorDialog(mainwin, _("Unable to find a suitable mirror."))
            
        self.repos.setProgressBar(None)
        pbar.destroy()

        if len(probs.keys()) > 0:
            errstr = []
            for key in probs.keys():
                errors = yum.misc.unique(probs[key])
                for error in errors:
                    errstr.append("%s: %s" %(key, error))

            downloadErrorDialog(mainwin, _("Errors were encountered while "
                                           "downloading packages."),
                                details = string.join(errstr, "\n"))
            
        return dlpkgs

    def checkDeps(self, mainwin):
        pbar = PirutDepsolveProgress(self,
                                     _("Resolving dependencies for updates"),
                                     mainwin)
        pbar.show()
        self.dsCallback = pbar

        # we need to nuke the ts so that we don't get confused if
        # resetting (#213421)
        del self.ts
        self.initActionTs() # make a new, blank ts to populate

        try:
            (result, msgs) = self.buildTransaction()
        except PirutCancelledError:
            self.dsCallback = None
            pbar.destroy()
            raise PirutDownloadError
        except (yum.Errors.RepoError, OSError), errmsg:
            self.dsCallback = None # we only wanted this here.  blah.
            pbar.destroy()
            
            d = PirutDetailsDialog(mainwin, gtk.MESSAGE_ERROR,
                                          [('gtk-ok', gtk.RESPONSE_OK)],
                                          _("Error downloading headers"),
                                          _("Errors were encountered while "
                                            "downloading package headers."))
            d.set_details("%s" %(errmsg,))
            d.run()
            d.destroy()
            raise PirutDownloadError
        
        self.dsCallback = None # we only wanted this here.  blah.
        pbar.destroy()

        if result == 1:
            self._undoDepInstalls()
            d = PirutDetailsDialog(mainwin, gtk.MESSAGE_ERROR,
                                 [('gtk-ok', gtk.RESPONSE_OK)],
                                 _("Error resolving dependencies"),
                                 _("Unable to resolve dependencies for some "
                                   "packages selected for installation."))
            d.set_details(string.join(msgs, "\n"))
            d.run()
            d.destroy()
            raise PirutDependencyError

    def depDetails(self, mainwin):
        self.tsInfo.makelists()
        if (len(self.tsInfo.depinstalled) > 0 or 
            len(self.tsInfo.depupdated) > 0 or
            len(self.tsInfo.depremoved) > 0):
            d = PirutDetailsDialog(mainwin, gtk.MESSAGE_INFO,
                                 [('gtk-cancel', gtk.RESPONSE_CANCEL),
                                  (_("Continue"), gtk.RESPONSE_OK, 'gtk-ok')],
                                 _("Dependencies added"),
                                 _("Updating these packages requires "
                                   "additional package changes for proper "
                                   "operation."))

            b = gtk.TextBuffer()
            tag = b.create_tag('bold')
            tag.set_property('weight', pango.WEIGHT_BOLD)
            tag = b.create_tag('indented')
            tag.set_property('left-margin', 10)
            types=[(self.tsInfo.depinstalled,_("Adding for dependencies:\n")),
                   (self.tsInfo.depremoved, _("Removing for dependencies:\n")),
                   (self.tsInfo.depupdated, _("Updating for dependencies:\n"))]
            for (lst, strng) in types:
                if len(lst) > 0:
                    i = b.get_end_iter()
                    b.insert_with_tags_by_name(i, strng, "bold")
                    for txmbr in lst:
                        i = b.get_end_iter()
                        (n,a,e,v,r) = txmbr.pkgtup
                        b.insert_with_tags_by_name(i, "%s-%s-%s\n" % (n,v,r),
                                                   "indented")
            d.set_details(buffer = b)
            timeout = 20
            if len(self.tsInfo.depremoved) > 0:
                d.expand_details()
                timeout = None
            rc = d.run(timeout=timeout)
            d.destroy()
            if rc != gtk.RESPONSE_OK:
                self._undoDepInstalls()
                raise PirutError

    def _undoDepInstalls(self):
        # clean up after ourselves in the case of failures
        for txmbr in self.tsInfo:
            if txmbr.isDep:
                self.tsInfo.remove(txmbr.po.pkgtup)
        # FIXME: this is a crude workaround for #242368 and should
        # go away once yum 3.2.6 comes out
        if hasattr(self, '_dcobj'):
            self._dcobj.already_seen = {}
            self._dcobj.already_seen_removed = {}

    def checkSignatures(self, pkgs, mainwin):
        def keyImportCallback(keydict):
            po = keydict["po"]
            userid = keydict["userid"]
            hexkeyid = keydict["hexkeyid"]
            keyurl = keydict["keyurl"]
            
            d = gtk.MessageDialog(mainwin, gtk.DIALOG_MODAL,
                                  gtk.MESSAGE_QUESTION,
                                  message_format = _("Import key?"))
            sec = _("The package %s is signed with a key "
                  "%s (0x%s) from %s.  Would you like to "
                  "import this key?") %(po, userid, hexkeyid, keyurl)
            d.format_secondary_text(sec)
            b = d.add_button('gtk-cancel', gtk.RESPONSE_CANCEL)
            b = d.add_button(_("_Import key"), gtk.RESPONSE_OK)
            b.set_image(gtk.image_new_from_stock(gtk.STOCK_OK,
                                                 gtk.ICON_SIZE_BUTTON))
            rc = d.run()
            d.destroy()
        
            if rc != gtk.RESPONSE_OK:
                return False
            return True

        
        pbar = PirutProgressCallback(_("Verifying packages"),
                                     mainwin, len(pkgs))
        for po in pkgs:
            try:
                pbar.set_pbar_text("Checking %s" %(po,))
                result, errmsg = self.sigCheckPkg(po)
                pbar.next_task()
            except PirutCancelledError:
                raise PirutVerifyError

            if result == 0:
                continue
            elif result == 1:
                found = True
                try:
                    self.getKeyForPackage(po, fullaskcb = keyImportCallback)
                except yum.Errors.YumBaseError, errmsg:
                    found = False
                if found:
                    continue

            # if we got here, either it failed to verify originally or failed
            # when we attempted to do an automagic import

            d = PirutDetailsDialog(mainwin, gtk.MESSAGE_ERROR,
                                   text = _("Unable to verify %s") %(po,))
            d.set_details("%s" %(errmsg,))

            if not self.unsignedok:
                pbar.destroy()
                d.add_button(_("_Close"), gtk.RESPONSE_CLOSE, 'gtk-close')
            else:
                d.format_secondary_markup(_("Malicious software can damage "
                                            "your computer or cause other "
                                            "harm.  Are you sure you wish "
                                            "to install this package?"))
                b = d.add_button(_("_Cancel"), gtk.RESPONSE_CANCEL,
                                 'gtk-cancel')
                b = d.add_button(_("_Install anyway"), gtk.RESPONSE_OK,
                                 'gtk-ok')
                d.set_default_response(gtk.RESPONSE_CANCEL)
            rc = d.run()
            d.destroy()
            if rc != gtk.RESPONSE_OK:
                raise PirutVerifyError
            
        pbar.destroy()

    def runTransaction(self, mainwin):
        def transactionErrors(errs):
            d = PirutDetailsDialog(mainwin, gtk.MESSAGE_ERROR,
                                          buttons = [('gtk-ok', 0)],
                                          text = _("Error updating software"))
            d.format_secondary_text(_("There were errors encountered in "
                                      "trying to update the software "
                                      "you selected"))
            d.set_details("%s" % '\n'.join(map(lambda x: x[0], errs.value)))
            d.run()
            d.destroy()

        def blacklistRemoveWarning(pkgs):
            d = PirutDetailsDialog(mainwin, gtk.MESSAGE_WARNING,
                                   buttons = [('gtk-cancel',gtk.RESPONSE_CANCEL),
                                              (_("_Remove anyway"), gtk.RESPONSE_OK, 'gtk-ok')],                                              
                                   text = _("Removing critical software"))
            d.format_secondary_text(_("Some of the software which you are "
                                      "removing is either critical software "
                                      "for system functionality or required "
                                      "by such software.  Are you sure you "
                                      "want to continue?"))
            txt = ""
            for po in pkgs:
                txt += "%s\n" %(po,)
            d.set_details(txt)
            
            rc = d.run()
            d.destroy()
            return rc

        def kernelRemoveWarning(pkgs):
            d = PirutDetailsDialog(mainwin, gtk.MESSAGE_WARNING,
                                   buttons = [('gtk-cancel',gtk.RESPONSE_CANCEL),
                                              (_("_Remove anyway"), gtk.RESPONSE_OK, 'gtk-ok')],                                              
                                   text = _("Removing critical software"))
            d.format_secondary_text(_("Removing this could leave you with "
                                      "no kernels and thus lead to a "
                                      "non-bootable system.  Are you sure "
                                      "you want to continue?"))
            rc = d.run()
            d.destroy()
            return rc
                                   


        # FIXME: does this belong here?
        blacked = []
        for txmbr in self.tsInfo.removed:
            if (txmbr.po.returnSimple('name') in remove_blacklist and
                len(self.tsInfo.matchNaevr(name=txmbr.po.returnSimple('name'))) == 1):
                blacked.append(txmbr.po)
        if len(blacked) > 0:
            rc = blacklistRemoveWarning(blacked)
            if rc != gtk.RESPONSE_OK:
                raise PirutError


        del self.ts
        self.initActionTs() # make a new, blank ts to populate
        self.populateTs(keepold=0)
        self.ts.check() #required for ordering
        self.ts.order() # order

        # set up the transaction to record output from scriptlets
        # this is pretty ugly...
        rpm.setVerbosity(rpm.RPMLOG_INFO)
        (r, w) = os.pipe()
        rf = os.fdopen(r, 'r') 
        wf = os.fdopen(w, 'w')
        self.ts.ts.scriptFd = wf.fileno()
        rpm.setLogFile(wf)

        tsprog = Progress.PirutTransactionCallback(_("Updating software"),
                                                   mainwin)
        tsprog.setReadPipe(rf)
        tsprog.show()
        tsprog.set_markup("<i>%s</i>" %(_("Preparing transaction")))
        try:
            tserrors = yum.YumBase.runTransaction(self, yum.rpmtrans.RPMTransaction(self, display=tsprog))
        except (yum.Errors.YumBaseError, PirutError), err:
            rpm.setLogFile(sys.stderr)
            rpm.setVerbosity(rpm.RPMLOG_NOTICE)
            wf.close()            
            tsprog.destroy()
            
            # FIXME: these errors are actually pretty bad and should be
            # formatted better
            transactionErrors(err)
            raise PirutError

        # reset rpm bits and get the output
        rpm.setLogFile(sys.stderr)
        rpm.setVerbosity(rpm.RPMLOG_NOTICE)                                 
        del self.ts
        wf.close()
        
        tsprog.destroy()
        return tsprog.getOutput()

    def applyChanges(self, mainwin, downloadonly=False):
        """Apply all of the packaging changes requested."""
        # do depsolve.  determine if we've added anything or not.
        self.checkDeps(mainwin)
        self.depDetails(mainwin)

        # download and verify packages
        dlpkgs = self.downloadPackages(mainwin)
        self.checkSignatures(dlpkgs, mainwin)

        # run transaction
        if not downloadonly:
            return self.runTransaction(mainwin)

    def quit(self, *args, **kwargs):
        # FIXME: should make sure we close down access to lock files and dbs
        # cleanly here
        try:
            self.closeRpmDB()
        except Exception, e:
            print >> sys.stderr, "Error closing rpmdb: ", e

        if kwargs.has_key("unlock") and kwargs["unlock"]:
            self.doUnlock(YUM_PID_FILE)
        try:
            gtk.main_quit()
        except:
            pass
        sys.exit(0)

def startupError(err):
    d = PirutDetailsDialog(None, gtk.MESSAGE_ERROR,
                           [(_("Exit"), gtk.RESPONSE_OK, 'gtk-quit')],
                           _("Config error."),
                           _("Unable to start due to a configuration "
                             "error."))
    d.set_details(str(err))
    d.run()
    d.destroy()
    sys.exit(2)    

_added_gettext_domains = {}
def sanitizeString(s, translate = True):
    if len(s) == 0:
        return s

    if not translate:
        i18ndomains = []
    elif hasattr(rpm, "expandMacro"):
        i18ndomains = rpm.expandMacro("%_i18ndomains").split(":")
    else:
        i18ndomains = ["redhat-dist"]
        
    # iterate over i18ndomains add to textdomain(), then translate
    for d in i18ndomains:
        if d not in _added_gettext_domains:
            try: 
                #  This horrible hack works around the python split() in gettext
                # problem. Example file is with a problem is:
                # /usr/share/locale/de/LC_MESSAGES/redhat-dist.mo
                textdomain(d)
            except AttributeError:
                pass
            _added_gettext_domains[d] = True
    s = _(s)
        
    s = s.replace("\n\n", "\x00")
    s = s.replace("\n", " ")
    s = s.replace("\x00", "\n\n")
    s = s.replace("&", "&amp;")
    s = s.replace("<", "&lt;")
    s = s.replace(">", "&gt;")
    s = utf8(s)
    return s
    
def outputDictAsTextBuffer(output):
    """Converts a dictionary of pkg -> package output to a nicely formatted
    TextBuffer."""
    b = gtk.TextBuffer()
    tag = b.create_tag('b')
    tag.set_property('weight', pango.WEIGHT_BOLD)
    tag = b.create_tag('in')
    tag.set_property('left-margin', 10)
    
    for (pkg, out) in output.items():
        if pkg is not None:
            b.insert_with_tags_by_name(b.get_end_iter(), "%s\n" % pkg, "b")
        b.insert_with_tags_by_name(b.get_end_iter(), out, "in")
    return b
